<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raiku 3D Subway Runner</title>
<style>
  body{margin:0;overflow:hidden;font-family:Arial;}
  canvas{display:block;}
  #startScreen,#gameOverScreen{
    position:absolute;inset:0;display:flex;flex-direction:column;
    align-items:center;justify-content:center;
    background:rgba(0,0,0,0.7);color:white;z-index:10;
  }
  #startScreen.hidden,#gameOverScreen.hidden{opacity:0;pointer-events:none;}
  button{padding:10px 20px;font-size:16px;border:none;border-radius:8px;background:#007bff;color:white;margin-top:10px;cursor:pointer;}
  #hud{position:absolute;top:10px;left:10px;color:white;font-size:20px;z-index:5;}
</style>
</head>
<body>
<div id="startScreen">
  <h1>Tap to Play</h1>
  <button id="startBtn">Start</button>
  <p style="font-size:13px;color:#ccc;">Swipe left/right or arrow keys to move</p>
</div>
<div id="gameOverScreen" class="hidden">
  <h1>Game Over</h1>
  <p>Score: <span id="finalScore">0</span></p>
  <button id="restartBtn">Restart</button>
</div>
<div id="hud">Score: 0</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script>
let scene,camera,renderer;
let player,lanes=[-2,0,2],currentLane=1;
let obstacles=[],score=0,gameOver=false,gameStarted=false;
let roadSegments=[];

init();
function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87CEEB);

  camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(0,6,8);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light=new THREE.DirectionalLight(0xffffff,1);
  light.position.set(0,10,10);
  scene.add(light);
  scene.add(new THREE.AmbientLight(0x555555));

  // Road
  const roadMat=new THREE.MeshPhongMaterial({color:0x333333});
  for(let i=0;i<5;i++){
    const geom=new THREE.BoxGeometry(6,0.1,20);
    const seg=new THREE.Mesh(geom,roadMat);
    seg.position.z=-i*20;
    scene.add(seg);
    roadSegments.push(seg);
  }

  // Player
  const playerGeom=new THREE.BoxGeometry(1,2,1);
  const playerMat=new THREE.MeshPhongMaterial({color:0xff0000});
  player=new THREE.Mesh(playerGeom,playerMat);
  player.position.set(lanes[currentLane],1,0);
  scene.add(player);

  // Input
  window.addEventListener("keydown",e=>{
    if(!gameStarted)return;
    if(e.key==="ArrowLeft"&&currentLane>0){currentLane--;player.position.x=lanes[currentLane];}
    if(e.key==="ArrowRight"&&currentLane<2){currentLane++;player.position.x=lanes[currentLane];}
  });
  // Touch swipe
  let startX=0;
  window.addEventListener("touchstart",e=>{startX=e.touches[0].clientX;});
  window.addEventListener("touchend",e=>{
    if(!gameStarted)return;
    let dx=e.changedTouches[0].clientX-startX;
    if(dx>30&&currentLane<2){currentLane++;player.position.x=lanes[currentLane];}
    else if(dx<-30&&currentLane>0){currentLane--;player.position.x=lanes[currentLane];}
  });

  window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
}

function spawnObstacle(){
  const laneIndex=Math.floor(Math.random()*3);
  const obsGeom=new THREE.BoxGeometry(1.5,2,1.5);
  const obsMat=new THREE.MeshPhongMaterial({color:Math.random()*0xffffff});
  const obs=new THREE.Mesh(obsGeom,obsMat);
  obs.position.set(lanes[laneIndex],1,-50);
  scene.add(obs);
  obstacles.push(obs);
}

function startGame(){
  gameStarted=true;gameOver=false;score=0;obstacles=[];
  document.getElementById("startScreen").classList.add("hidden");
  document.getElementById("gameOverScreen").classList.add("hidden");
  update();
}

function restartGame(){
  gameOver=false;score=0;obstacles=[];
  currentLane=1;player.position.set(lanes[currentLane],1,0);
  document.getElementById("gameOverScreen").classList.add("hidden");
  update();
}

function update(){
  if(!gameStarted||gameOver)return;
  requestAnimationFrame(update);

  // Move road
  roadSegments.forEach(seg=>{
    seg.position.z+=0.5+score/500;
    if(seg.position.z>10)seg.position.z-=100;
  });

  // Spawn obstacles
  if(Math.random()<0.02)spawnObstacle();

  // Move obstacles
  obstacles.forEach((obs,i)=>{
    obs.position.z+=0.5+score/500;
    if(obs.position.z>5){scene.remove(obs);obstacles.splice(i,1);}
    if(Math.abs(obs.position.z-player.position.z)<1 && Math.abs(obs.position.x-player.position.x)<0.9){
      gameOver=true;
      document.getElementById("finalScore").textContent=score;
      document.getElementById("gameOverScreen").classList.remove("hidden");
      return;
    }
  });

  // Camera follow
  camera.position.x=player.position.x;
  camera.position.z=player.position.z+8;
  camera.lookAt(player.position.x,player.position.y,player.position.z);

  score++;
  document.getElementById("hud").innerText="Score: "+score;
  renderer.render(scene,camera);
}

document.getElementById("startBtn").onclick=startGame;
document.getElementById("restartBtn").onclick=restartGame;
</script>
</body>
</html>
