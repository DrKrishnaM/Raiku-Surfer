<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Raiku 3D Runner</title>
<style>
  body{margin:0;overflow:hidden;}
  canvas{display:block;}
  #hud{
    position:absolute;top:10px;left:10px;color:white;font-size:20px;font-family:Arial;
    z-index:5;
  }
</style>
</head>
<body>
<div id="hud">Score: 0</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
let scene, camera, renderer;
let player, road, obstacles=[];
let laneWidth=4;
let score=0;
let gameOver=false;

init();
animate();

function init(){
  scene=new THREE.Scene();
  scene.background=new THREE.Color(0x87CEEB);

  camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
  camera.position.set(0,8,12);
  camera.lookAt(0,0,0);

  renderer=new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth,window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Light
  const light=new THREE.DirectionalLight(0xffffff,1);
  light.position.set(0,10,10);
  scene.add(light);

  // Road
  const roadGeom=new THREE.BoxGeometry(12,0.1,200);
  const roadMat=new THREE.MeshPhongMaterial({color:0x333333});
  road=new THREE.Mesh(roadGeom,roadMat);
  road.position.z=-90;
  scene.add(road);

  // Player (Raiku)
  const playerGeom=new THREE.BoxGeometry(1,2,1);
  const playerMat=new THREE.MeshPhongMaterial({color:0xff0000});
  player=new THREE.Mesh(playerGeom,playerMat);
  player.position.set(0,1,0);
  scene.add(player);

  // Event for horizontal move
  window.addEventListener("keydown",(e)=>{
    if(e.key==="ArrowLeft")player.position.x-=laneWidth;
    if(e.key==="ArrowRight")player.position.x+=laneWidth;
    if(player.position.x<-laneWidth)player.position.x=-laneWidth;
    if(player.position.x>laneWidth)player.position.x=laneWidth;
  });

  window.addEventListener("resize",()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight)});
}

function spawnObstacle(){
  const lanes=[-laneWidth,0,laneWidth];
  const lane=lanes[Math.floor(Math.random()*3)];
  const geom=new THREE.BoxGeometry(1.5,2,1.5);
  const mat=new THREE.MeshPhongMaterial({color:Math.random()*0xffffff});
  const car=new THREE.Mesh(geom,mat);
  car.position.set(lane,1,-100);
  scene.add(car);
  obstacles.push(car);
}

function animate(){
  if(gameOver)return;
  requestAnimationFrame(animate);

  // Spawn obstacles
  if(Math.random()<0.02)spawnObstacle();

  // Move obstacles
  obstacles.forEach((obs,i)=>{
    obs.position.z+=0.5+score/500;
    if(obs.position.z>5){scene.remove(obs);obstacles.splice(i,1);}
    // Collision
    if(Math.abs(obs.position.z-player.position.z)<1 && Math.abs(obs.position.x-player.position.x)<1){
      gameOver=true;
      alert("Game Over! Score: "+score);
    }
  });

  // Move road (optional: scrolling effect)
  road.position.z+=0.5+score/500;
  if(road.position.z>0)road.position.z=-90;

  // Update camera
  camera.position.x=player.position.x;
  camera.lookAt(player.position.x,player.position.y,player.position.z-5);

  score++;
  document.getElementById("hud").innerText="Score: "+score;

  renderer.render(scene,camera);
}
</script>
</body>
</html>
